{"version":1,"windowDimensions":{"x":0,"y":24,"width":1366,"height":744,"maximized":true},"grammars":{"grammarOverridesByPath":{}},"project":{"deserializer":"Project","paths":["/home/anirudh/Desktop/rob"],"buffers":[{"id":"18abca5ccb0cbb15ef946c00561405b4","text":"#include \"simpletools.h\"          // Include simpletools header\n#include \"ping.h\"                 // Include ping header\n#include \"abdrive.h\"              // Include abdrive header\n\n#define SIDE 123\n#define NORTH 0\n#define EAST 1\n#define SOUTH 2\n#define WEST 3\n#define STOP 950\n#define reduce 450\n#define TURN 1050\n#define finalSpeed 128\n\nint currentDirection = NORTH;\n\n// void turnDirection(int direction){\n//   drive_speed(0, 0);\n//   int diff = currentDirection - direction;\n//   drive_goto(-(25 * diff), (26 * diff));\n//   currentDirection = direction;\n//   drive_speed(128, 128);\n//   return;\n// }\n\n\n\nvoid turnDirection(int direction){\n  if(currentDirection == direction){\n    return;\n  }\n  //drive_speed(30, 30);\n  int diff = currentDirection - direction;\n\n  if (diff > 0){\n    drive_speed(60, 128);\n  } else {\n    drive_speed(128, 60);\n  }\n\n  pause(TURN * abs(diff));\n  currentDirection = direction;\n  drive_speed(128, 128);\n  return;\n}\n\nint checkNext(int input[], int index, int size){\n  if (index >= size - 1){\n    return -10;\n  }\n\n  int curr = input[index];\n  int target = input[index + 1];\n  int diff = target - curr;\n  //print(\"%d\\n\", diff);\n  return diff;\n}\n\nint numOfTurns(int input[], int size){\n  int i = 0;\n  int turns = 0;\n  int last = 4;\n  for(i = 0; i < size; i++){\n    if (checkNext(input, i, size) != last){\n      turns++;\n      last = checkNext(input, i, size);\n    }\n  }\n  print(\"%d \\n\", turns);\n  return turns;\n}\n\nint check = 0;\n\nvoid move(int input[], int index, int sizeOfInput){\n\n  check++;\n\n  int diff = checkNext(input, index, sizeOfInput);\n\n  if(diff == -10){\n    drive_speed(0, 0);\n    return;\n  }\n\n  int counter = 0;\n  //print(\"%i\\n\", counter);\n\n  switch (diff){\n    //move right until diff is 1\n    case 1:\n      turnDirection(EAST);\n      counter = 0;\n      while(diff == 1){\n        ++index;\n        counter++;\n        diff = checkNext(input, index, sizeOfInput);\n        //print(\"hi\");\n      }\n      drive_speed(finalSpeed, finalSpeed);\n      if (check == 1 || check == numOfTurns(input, sizeOfInput)){\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce));\n        pause((counter - 0.5) * STOP);\n      } else {\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - (reduce * 2)));\n        pause((counter - 1) * STOP);\n      }\n      break;\n    //move left until diff is -1\n    case -1:\n      turnDirection(WEST);\n      counter = 0;\n      while(diff == -1){\n        ++index;\n        counter++;\n        diff = checkNext(input, index, sizeOfInput);\n        //print(\"hi\");\n      }\n      drive_speed(finalSpeed, finalSpeed);\n      if (check == 1 || check == numOfTurns(input, sizeOfInput)){\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce));\n        pause((counter - 0.5) * STOP);\n      } else {\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce - reduce));\n        pause((counter - 1) * STOP);\n      }\n      break;\n    //move forward until diff is 4\n    case 4:\n      turnDirection(NORTH);\n      counter = 0;\n      while(diff == 4){\n        ++index;\n        counter++;\n        diff = checkNext(input, index, sizeOfInput);\n        //print(\"hi\");\n      }\n      drive_speed(finalSpeed, finalSpeed);\n      if (check == 1 || check == numOfTurns(input, sizeOfInput)){\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce));\n        pause((counter - 0.5) * STOP);\n      } else {\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce - reduce));\n        pause((counter - 1) * STOP);\n      }\n      break;\n    //move backwards until diff is -4\n    default:\n      turnDirection(SOUTH);\n      counter = 0;\n      while(diff == -4){\n        ++index;\n        counter++;\n        diff = checkNext(input, index, sizeOfInput);\n        //print(\"hi\");\n      }\n      drive_speed(finalSpeed, finalSpeed);\n      if (check == 1 || check == numOfTurns(input, sizeOfInput)){\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce));\n        pause((counter - 0.5) * STOP);\n      } else {\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce - reduce));\n        pause((counter - 1) * STOP);\n      }\n  }\n  //print(\"%i\\n\", counter);\n  move(input, index, sizeOfInput);\n}\n\nint main(){\n  int inp[] = {(-3), 1, 5, 6, 7, 11, 15, 16};\n  //drive_goto(SIDE, SIDE);\n  int len = sizeof(inp)/sizeof(inp[0]);\n  //drive_goto(2 * SIDE / 5, 2 * SIDE / 5);\n  drive_speed(128, 128);\n  move(inp, 0, len);\n  drive_speed(0, 0);\n}\n","defaultMarkerLayerId":"0","markerLayers":{"0":{"id":"0","maintainHistory":false,"markersById":{},"version":2},"1":{"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"id":"2","maintainHistory":true,"markersById":{"1":{"range":{"start":{"row":4,"column":8},"end":{"row":4,"column":12}},"properties":{"type":"selection","goalScreenRange":null,"autoscroll":false,"preserveFolds":true},"reversed":false,"tailed":true,"valid":true,"invalidate":"never"}},"version":2},"4":{"id":"4","maintainHistory":false,"markersById":{},"version":2},"6":{"id":"6","maintainHistory":false,"markersById":{},"version":2},"7":{"id":"7","maintainHistory":false,"markersById":{},"version":2},"9":{"id":"9","maintainHistory":false,"markersById":{},"version":2},"11":{"id":"11","maintainHistory":false,"markersById":{},"version":2}},"nextMarkerLayerId":12,"history":{"version":3,"nextCheckpointId":11,"undoStack":[{"type":"group-start","snapshot":{"2":{"1":{"range":[[0,0],[178,0]],"properties":{"type":"selection","goalScreenRange":null,"autoscroll":false,"preserveFolds":true},"reversed":false,"tailed":true,"valid":true,"invalidate":"never"}}}},{"type":"change","content":{"oldRange":[[0,0],[178,0]],"newRange":[[0,0],[0,0]],"oldText":"#include \"simpletools.h\"          // Include simpletools header\n#include \"ping.h\"                 // Include ping header\n#include \"abdrive.h\"              // Include abdrive header\n\n#define SIDE 123\n#define NORTH 0\n#define EAST 1\n#define SOUTH 2\n#define WEST 3\n#define STOP 950\n#define reduce 450\n#define TURN 1050\n#define finalSpeed 128\n\nint currentDirection = NORTH;\n\n// void turnDirection(int direction){\n//   drive_speed(0, 0);\n//   int diff = currentDirection - direction;\n//   drive_goto(-(25 * diff), (26 * diff));\n//   currentDirection = direction;\n//   drive_speed(128, 128);\n//   return;\n// }\n\n\n\nvoid turnDirection(int direction){\n  if(currentDirection == direction){\n    return;\n  }\n  //drive_speed(30, 30);\n  int diff = currentDirection - direction;\n\n  if (diff > 0){\n    drive_speed(60, 128);\n  } else {\n    drive_speed(128, 60);\n  }\n\n  pause(TURN * abs(diff));\n  currentDirection = direction;\n  drive_speed(128, 128);\n  return;\n}\n\nint checkNext(int input[], int index, int size){\n  if (index >= size - 1){\n    return -10;\n  }\n\n  int curr = input[index];\n  int target = input[index + 1];\n  int diff = target - curr;\n  //print(\"%d\\n\", diff);\n  return diff;\n}\n\nint numOfTurns(int input[], int size){\n  int i = 0;\n  int turns = 0;\n  int last = 4;\n  for(i = 0; i < size; i++){\n    if (checkNext(input, i, size) != last){\n      turns++;\n      last = checkNext(input, i, size);\n    }\n  }\n  print(\"%d \\n\", turns);\n  return turns;\n}\n\nint check = 0;\n\nvoid move(int input[], int index, int sizeOfInput){\n\n  check++;\n\n  int diff = checkNext(input, index, sizeOfInput);\n\n  if(diff == -10){\n    drive_speed(0, 0);\n    return;\n  }\n\n  int counter = 0;\n  //print(\"%i\\n\", counter);\n\n  switch (diff){\n    //move right until diff is 1\n    case 1:\n      turnDirection(EAST);\n      counter = 0;\n      while(diff == 1){\n        ++index;\n        counter++;\n        diff = checkNext(input, index, sizeOfInput);\n        //print(\"hi\");\n      }\n      drive_speed(finalSpeed, finalSpeed);\n      if (check == 1 || check == numOfTurns(input, sizeOfInput)){\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce));\n        pause((counter - 0.5) * STOP);\n      } else {\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - (reduce * 2)));\n        pause((counter - 1) * STOP);\n      }\n      break;\n    //move left until diff is -1\n    case -1:\n      turnDirection(WEST);\n      counter = 0;\n      while(diff == -1){\n        ++index;\n        counter++;\n        diff = checkNext(input, index, sizeOfInput);\n        //print(\"hi\");\n      }\n      drive_speed(finalSpeed, finalSpeed);\n      if (check == 1 || check == numOfTurns(input, sizeOfInput)){\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce));\n        pause((counter - 0.5) * STOP);\n      } else {\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce - reduce));\n        pause((counter - 1) * STOP);\n      }\n      break;\n    //move forward until diff is 4\n    case 4:\n      turnDirection(NORTH);\n      counter = 0;\n      while(diff == 4){\n        ++index;\n        counter++;\n        diff = checkNext(input, index, sizeOfInput);\n        //print(\"hi\");\n      }\n      drive_speed(finalSpeed, finalSpeed);\n      if (check == 1 || check == numOfTurns(input, sizeOfInput)){\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce));\n        pause((counter - 0.5) * STOP);\n      } else {\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce - reduce));\n        pause((counter - 1) * STOP);\n      }\n      break;\n    //move backwards until diff is -4\n    default:\n      turnDirection(SOUTH);\n      counter = 0;\n      while(diff == -4){\n        ++index;\n        counter++;\n        diff = checkNext(input, index, sizeOfInput);\n        //print(\"hi\");\n      }\n      drive_speed(finalSpeed, finalSpeed);\n      if (check == 1 || check == numOfTurns(input, sizeOfInput)){\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce));\n        pause((counter - 0.5) * STOP);\n      } else {\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce - reduce));\n        pause((counter - 1) * STOP);\n      }\n  }\n  //print(\"%i\\n\", counter);\n  move(input, index, sizeOfInput);\n}\n\nint main(){\n  int inp[] = {(-3), 1, 5, 6, 7, 11, 15, 16};\n  //drive_goto(SIDE, SIDE);\n  int len = sizeof(inp)/sizeof(inp[0]);\n  //drive_goto(2 * SIDE / 5, 2 * SIDE / 5);\n  drive_speed(128, 128);\n  move(inp, 0, len);\n  drive_speed(0, 0);\n}\n","newText":""}},{"type":"group-end","snapshot":{"2":{"1":{"range":[[0,0],[0,0]],"properties":{"type":"selection","goalScreenRange":null,"autoscroll":false,"preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}}}},{"type":"group-start","snapshot":{"2":{"1":{"range":[[0,0],[0,0]],"properties":{"type":"selection","goalScreenRange":null,"autoscroll":false,"preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}}}},{"type":"change","content":{"oldRange":[[0,0],[0,0]],"newRange":[[0,0],[178,0]],"oldText":"","newText":"#include \"simpletools.h\"          // Include simpletools header\n#include \"ping.h\"                 // Include ping header\n#include \"abdrive.h\"              // Include abdrive header\n\n#define SIDE 123\n#define NORTH 0\n#define EAST 1\n#define SOUTH 2\n#define WEST 3\n#define STOP 950\n#define reduce 450\n#define TURN 1050\n#define finalSpeed 128\n\nint currentDirection = NORTH;\n\n// void turnDirection(int direction){\n//   drive_speed(0, 0);\n//   int diff = currentDirection - direction;\n//   drive_goto(-(25 * diff), (26 * diff));\n//   currentDirection = direction;\n//   drive_speed(128, 128);\n//   return;\n// }\n\n\n\nvoid turnDirection(int direction){\n  if(currentDirection == direction){\n    return;\n  }\n  //drive_speed(30, 30);\n  int diff = currentDirection - direction;\n\n  if (diff > 0){\n    drive_speed(60, 128);\n  } else {\n    drive_speed(128, 60);\n  }\n\n  pause(TURN * abs(diff));\n  currentDirection = direction;\n  drive_speed(128, 128);\n  return;\n}\n\nint checkNext(int input[], int index, int size){\n  if (index >= size - 1){\n    return -10;\n  }\n\n  int curr = input[index];\n  int target = input[index + 1];\n  int diff = target - curr;\n  //print(\"%d\\n\", diff);\n  return diff;\n}\n\nint numOfTurns(int input[], int size){\n  int i = 0;\n  int turns = 0;\n  int last = 4;\n  for(i = 0; i < size; i++){\n    if (checkNext(input, i, size) != last){\n      turns++;\n      last = checkNext(input, i, size);\n    }\n  }\n  print(\"%d \\n\", turns);\n  return turns;\n}\n\nint check = 0;\n\nvoid move(int input[], int index, int sizeOfInput){\n\n  check++;\n\n  int diff = checkNext(input, index, sizeOfInput);\n\n  if(diff == -10){\n    drive_speed(0, 0);\n    return;\n  }\n\n  int counter = 0;\n  //print(\"%i\\n\", counter);\n\n  switch (diff){\n    //move right until diff is 1\n    case 1:\n      turnDirection(EAST);\n      counter = 0;\n      while(diff == 1){\n        ++index;\n        counter++;\n        diff = checkNext(input, index, sizeOfInput);\n        //print(\"hi\");\n      }\n      drive_speed(finalSpeed, finalSpeed);\n      if (check == 1 || check == numOfTurns(input, sizeOfInput)){\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce));\n        pause((counter - 0.5) * STOP);\n      } else {\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - (reduce * 2)));\n        pause((counter - 1) * STOP);\n      }\n      break;\n    //move left until diff is -1\n    case -1:\n      turnDirection(WEST);\n      counter = 0;\n      while(diff == -1){\n        ++index;\n        counter++;\n        diff = checkNext(input, index, sizeOfInput);\n        //print(\"hi\");\n      }\n      drive_speed(finalSpeed, finalSpeed);\n      if (check == 1 || check == numOfTurns(input, sizeOfInput)){\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce));\n        pause((counter - 0.5) * STOP);\n      } else {\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce - reduce));\n        pause((counter - 1) * STOP);\n      }\n      break;\n    //move forward until diff is 4\n    case 4:\n      turnDirection(NORTH);\n      counter = 0;\n      while(diff == 4){\n        ++index;\n        counter++;\n        diff = checkNext(input, index, sizeOfInput);\n        //print(\"hi\");\n      }\n      drive_speed(finalSpeed, finalSpeed);\n      if (check == 1 || check == numOfTurns(input, sizeOfInput)){\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce));\n        pause((counter - 0.5) * STOP);\n      } else {\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce - reduce));\n        pause((counter - 1) * STOP);\n      }\n      break;\n    //move backwards until diff is -4\n    default:\n      turnDirection(SOUTH);\n      counter = 0;\n      while(diff == -4){\n        ++index;\n        counter++;\n        diff = checkNext(input, index, sizeOfInput);\n        //print(\"hi\");\n      }\n      drive_speed(finalSpeed, finalSpeed);\n      if (check == 1 || check == numOfTurns(input, sizeOfInput)){\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce));\n        pause((counter - 0.5) * STOP);\n      } else {\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce - reduce));\n        pause((counter - 1) * STOP);\n      }\n  }\n  //print(\"%i\\n\", counter);\n  move(input, index, sizeOfInput);\n}\n\nint main(){\n  int inp[] = {(-3), 1, 5, 6, 7, 11, 15, 16};\n  //drive_goto(SIDE, SIDE);\n  int len = sizeof(inp)/sizeof(inp[0]);\n  //drive_goto(2 * SIDE / 5, 2 * SIDE / 5);\n  drive_speed(128, 128);\n  move(inp, 0, len);\n  drive_speed(0, 0);\n}\n"}},{"type":"change","content":{"oldRange":[[0,0],[0,0]],"newRange":[[0,0],[0,0]],"oldText":"","newText":""}},{"type":"group-end","snapshot":{"2":{"1":{"range":[[178,0],[178,0]],"properties":{"type":"selection","goalScreenRange":null,"autoscroll":false,"preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}}}}],"redoStack":[]},"encoding":"utf8","filePath":"/home/anirudh/Desktop/rob/newsmooth.c","digestWhenLastPersisted":"d7787605c5d447fc5af3a53ab7f6afeb48523bd8","preferredLineEnding":null,"nextMarkerId":102,"deserializer":"TextBuffer","version":5},{"id":"b5167922c51c816dada0dc77581874a2","text":"#include \"simpletools.h\"          // Include simpletools header\n#include \"ping.h\"                 // Include ping header\n#include \"abdrive.h\"              // Include abdrive header\n\n\n#define SIDE 40\n#define NORTH 0\n#define EAST 1\n#define SOUTH 2\n#define WEST 3\n#define cmToTicks (1 / 0.325)\n\n#define idealDist 9\n#define minDiff 2\n\n// default speed of the robot\n#define speed 128\n\n#define finalSpeed 128\n\n#define STOP 950\n#define reduce 450\n#define TURN 1050\n\n// factor by which speed of wheel changes to make a turn\n#define factor 2\n\n// A node in the linked list\ntypedef struct Node {\n    struct Node *next;\n    struct Node *prev;\n    int nodeNumber;\n} Node;\n\n\n// Stores head, tail and number of nodes in the linked list\ntypedef struct List {\n    struct Node *first;\n    struct Node *last;\n    int numberOfNodes;\n} List;\n\n\nList *list;\nList *listRev;\n\n// Defining global Variables\nint currentNode = 1;\nint destination;\nint currentDirection = NORTH;\nint lengthArr;\n\n\nint leftDist, rightDist;\nint leftTicksOld = 0, rightTicksOld = 0;\nint leftTicks = 0, rightTicks = 0;\n\n\n// Get the values from the right and left sensors\nvoid irDist() {\n\n    leftDist = 0;\n    rightDist = 0;\n\n    for(int dacVal = 0; dacVal < 160; dacVal += 8) {\n        dac_ctr(26, 0, dacVal);\n        freqout(11, 1, 38000);\n        leftDist += input(10);\n\n        dac_ctr(27, 1, dacVal);\n        freqout(1, 1, 38000);\n        rightDist += input(2);\n    }\n\n   //print(\"leftDist: %d\\trightDist: %d\\n\", leftDist, rightDist);\n}\n\n// Function to move the robot\nvoid moveRobot() {\n\n    int distError;\n\n    if(leftDist < 20 && rightDist < 20 && ((leftDist - rightDist) >= minDiff || (leftDist - rightDist) <= -minDiff)) {\n        distError = leftDist - rightDist;\n    } else if (rightDist < 20 && leftDist == 20 && ((idealDist - rightDist) >= minDiff || (idealDist - rightDist) <= -minDiff)) {\n        distError = idealDist - rightDist;\n    } else if (rightDist == 20 && leftDist < 20 && ((leftDist - idealDist) >= minDiff || (leftDist - idealDist) <= -minDiff)) {\n        distError = leftDist - idealDist;\n    } else {\n        distError = 0;\n    }\n\n    distError *= factor;\n    if(distError < 0) {\n        drive_speed(speed - distError, speed);\n    } else {\n        drive_speed(speed, speed + distError);\n    }\n    //drive_speed(speed - distError, speed + distError);\n}\n\n\nvoid moveDist() {\n    drive_getTicks(&leftTicks, &rightTicks);\n    leftTicksOld = leftTicks;\n    rightTicksOld = rightTicks;\n    while((leftTicks - leftTicksOld < (SIDE * cmToTicks)) && (rightTicks - rightTicksOld < (SIDE * cmToTicks)) && (ping_cm > 6)) {\n        irDist();\n        moveRobot();\n        drive_getTicks(&leftTicks, &rightTicks);\n        //print(\"new - %d \\t old - %d\\n\", leftTicks, leftTicksOld);\n    }\n    drive_speed(0, 0);\n}\n\n\n\nvoid turn(char* str){\n    if(str == \"left\"){\n        switch (currentDirection) {\n            case NORTH:\n            currentDirection = WEST;\n            break;\n            case WEST:\n            currentDirection = SOUTH;\n            break;\n            case SOUTH:\n            currentDirection = EAST;\n            break;\n            default:\n            currentDirection = NORTH;\n        }\n    } else {\n        switch (currentDirection) {\n            case NORTH:\n            currentDirection = EAST;\n            break;\n            case EAST:\n            currentDirection = SOUTH;\n            break;\n            case SOUTH:\n            currentDirection = WEST;\n            break;\n            default:\n            currentDirection = NORTH;\n        }\n    }\n}\n\nint lengthLL(List *temp) {\n    Node *head = temp -> first;\n    int len = 0;\n    while(head != NULL) {\n        len++;\n        head = head -> next;\n    }\n    return len;\n}\n\nvoid cutLL(List *list1) {\n    int length = lengthLL(list1);\n    Node *temp1 = list1 -> first;\n    for(int i = 0; temp1 != NULL; i++) {\n        Node *temp2 = temp1 -> next;\n        for(int j = i + 1; temp2 != NULL; j++) {\n            if(temp1 -> nodeNumber == temp2 -> nodeNumber) {\n                temp1 -> next = temp2 -> next;\n            }\n            temp2 = temp2 -> next;\n        }\n        temp1 = temp1 -> next;\n    }\n}\n\nvoid displayArray(int *arr) {\n    for(int i = 0; i < lengthArr; i++) {\n        print(\"%d : \", arr[i]);\n    }\n    print(\"\\n\");\n}\n\nint* LLtoArray(List *list1) {\n    lengthArr = lengthLL(list1) + 1;\n    Node *temp = list1 -> first;\n    int *arr = (int*) malloc (sizeof(int) * lengthArr);\n    arr[0] = -3;\n    for(int i = 1; i < lengthArr; i++) {\n        arr[i] = temp -> nodeNumber;\n        temp = temp -> next;\n    }\n\n    displayArray(arr);\n\n    return arr;\n}\n\n\nvoid printLL(List *temp) {\n    Node *node = temp -> first;\n    if(node == NULL) {\n        //print(\"List empty\");\n        return;\n    }\n    while(node != NULL) {\n        //print(\"%d --> \", node -> nodeNumber);\n        node = node -> next;\n    }\n    //print(\"\\n\");\n}\n\n\n// Add nodes to the linked list\nvoid prependNode() {\n    Node *node = (Node*)malloc(sizeof(Node));\n    node -> next = NULL;\n    node -> prev = NULL;\n    node -> nodeNumber = currentNode;\n    if (listRev -> last == NULL) {\n        listRev -> first = node;\n        listRev -> last = node;\n    } else {\n        node -> next = listRev -> first;\n        listRev -> first -> prev = node;\n        listRev -> first = node;\n    }\n    listRev -> numberOfNodes += 1;\n}\n\n\n// Add nodes to the linked list\nvoid appendNode() {\n    Node *node = (Node*)malloc(sizeof(Node));\n    node -> next = NULL;\n    node -> prev = NULL;\n    node -> nodeNumber = currentNode;\n    if (list -> first == NULL) {\n        list -> first = node;\n        list -> last = node;\n    } else {\n        list -> last -> next = node;\n        list -> last = node;\n    }\n    list -> numberOfNodes += 1;\n}\n\n\nvoid moveForward() {\n    switch(currentDirection) {\n        case NORTH:\n        currentNode += 4;\n        break;\n        case EAST:\n        currentNode += 1;\n        break;\n        case WEST:\n        currentNode -= 1;\n        break;\n        default:\n        currentNode -= 4;\n    }\n\n    //print(\"current node: %d\\n\", currentNode);\n\n    if(destination == 16 || destination == 13)\n        appendNode();\n\n    if(destination == 1 || destination == 4)\n        prependNode();\n\n    //drive_goto(cmToTicks * SIDE, cmToTicks * SIDE);\n    moveDist();\n\n}\n\n\nvoid reachNode () {\n    while(currentNode != destination) {\n        //relocate();\n        //turn left to check\n        drive_goto(-25, 26);\n        //relocate();\n        if (ping_cm(8) >= 30) {\n            turn(\"left\");\n            moveForward();\n        } else {\n            //become straight\n            drive_goto(25, -26);\n            //relocate();\n            //if blocked then turn right\n            if(ping_cm(8) <= 30) {\n                drive_goto(25, -26);\n                //relocate();\n                turn(\"right\");\n                //if blocked then right\n                //going back\n                if(ping_cm(8) <= 30) {\n                    turn(\"right\");\n                    drive_goto(25, -25);\n                    moveForward();\n                }\n                //continue to rigth\n                else {\n                    moveForward();\n                }\n            }\n            //if not blocked then continue straight\n            else {\n                moveForward();\n            }\n        }\n    }\n}\n\nvoid turnDirection(int direction){\n  if(currentDirection == direction){\n    return;\n  }\n  //drive_speed(30, 30);\n  int diff = currentDirection - direction;\n\n  if (diff > 0){\n    drive_speed(60, 128);\n  } else {\n    drive_speed(128, 60);\n  }\n\n  pause(TURN * abs(diff));\n  currentDirection = direction;\n  drive_speed(128, 128);\n  return;\n}\n\nint checkNext(int input[], int index, int size){\n  if (index >= size - 1){\n    return -10;\n  }\n\n  int curr = input[index];\n  int target = input[index + 1];\n  int diff = target - curr;\n  //print(\"%d\\n\", diff);\n  return diff;\n}\n\nint numOfTurns(int input[], int size){\n  int i = 0;\n  int turns = 0;\n  int last = 4;\n  for(i = 0; i < size; i++){\n    if (checkNext(input, i, size) != last){\n      turns++;\n      last = checkNext(input, i, size);\n    }\n  }\n  print(\"%d \\n\", turns);\n  return turns;\n}\n\nint check = 0;\n\nvoid move(int input[], int index, int sizeOfInput){\n\n  check++;\n\n  int diff = checkNext(input, index, sizeOfInput);\n\n  if(diff == -10){\n    drive_speed(0, 0);\n    return;\n  }\n\n  int counter = 0;\n  //print(\"%i\\n\", counter);\n\n  switch (diff){\n    //move right until diff is 1\n    case 1:\n      turnDirection(EAST);\n      counter = 0;\n      while(diff == 1){\n        ++index;\n        counter++;\n        diff = checkNext(input, index, sizeOfInput);\n        //print(\"hi\");\n      }\n      drive_speed(finalSpeed, finalSpeed);\n      if (check == 1 || check == numOfTurns(input, sizeOfInput)){\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce));\n        pause((counter - 0.5) * STOP);\n      } else {\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - (reduce * 2)));\n        pause((counter - 1) * STOP);\n      }\n      break;\n    //move left until diff is -1\n    case -1:\n      turnDirection(WEST);\n      counter = 0;\n      while(diff == -1){\n        ++index;\n        counter++;\n        diff = checkNext(input, index, sizeOfInput);\n        //print(\"hi\");\n      }\n      drive_speed(finalSpeed, finalSpeed);\n      if (check == 1 || check == numOfTurns(input, sizeOfInput)){\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce));\n        pause((counter - 0.5) * STOP);\n      } else {\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce - reduce));\n        pause((counter - 1) * STOP);\n      }\n      break;\n    //move forward until diff is 4\n    case 4:\n      turnDirection(NORTH);\n      counter = 0;\n      while(diff == 4){\n        ++index;\n        counter++;\n        diff = checkNext(input, index, sizeOfInput);\n        //print(\"hi\");\n      }\n      drive_speed(finalSpeed, finalSpeed);\n      if (check == 1 || check == numOfTurns(input, sizeOfInput)){\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce));\n        pause((counter - 0.5) * STOP);\n      } else {\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce - reduce));\n        pause((counter - 1) * STOP);\n      }\n      break;\n    //move backwards until diff is -4\n    default:\n      turnDirection(SOUTH);\n      counter = 0;\n      while(diff == -4){\n        ++index;\n        counter++;\n        diff = checkNext(input, index, sizeOfInput);\n        //print(\"hi\");\n      }\n      drive_speed(finalSpeed, finalSpeed);\n      if (check == 1 || check == numOfTurns(input, sizeOfInput)){\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce));\n        pause((counter - 0.5) * STOP);\n      } else {\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce - reduce));\n        pause((counter - 1) * STOP);\n      }\n  }\n  //print(\"%i\\n\", counter);\n  move(input, index, sizeOfInput);\n}\n\nvoid freeList(List *list1) {\n    Node *temp1 = list1 -> first;\n    Node *temp2 = temp1 -> next;\n    while(temp1 != list1 -> last) {\n        //print(\"%d freed\\n\", temp1 -> nodeNumber);\n        free(temp1);\n        temp1 = temp2;\n        temp2 = temp1 -> next;\n    }\n\n    free(temp1);\n}\n\n\nint main() {\n\n    list = malloc(sizeof(List));\n    list -> first = NULL;\n    list -> last = NULL;\n    list -> numberOfNodes = 0;\n\n    listRev = malloc(sizeof(List));\n    listRev -> first = NULL;\n    listRev -> last = NULL;\n    listRev -> numberOfNodes = 0;\n\n    //drive_goto(cmToTicks * SIDE, cmToTicks * SIDE);\n    moveDist();\n    //print(\"current node: %d\\n\", currentNode);\n\n    appendNode();\n\n    destination = 13;\n    reachNode();\n    //printLL(list);\n\n    destination = 16;\n    reachNode();\n    //printLL(list);\n\n    prependNode();\n\n    destination = 4;\n    reachNode();\n    //printLL(listRev);\n\n    destination = 1;\n    reachNode();\n    //printLL(listRev);\n\n    cutLL(list);\n    cutLL(listRev);\n\n    int *finalArray;\n    int len;\n\n    if(lengthLL(list) <= lengthLL(listRev)) {\n        finalArray = LLtoArray(list);\n    } else {\n        finalArray = LLtoArray(listRev);\n    }\n\n    freeList(list);\n    freeList(listRev);\n\n    if (ping_cm(8) >= 30) {\n        // drive_goto(SIDE * cmToTicks, SIDE * cmToTicks);\n        moveDist();\n    } else {\n        //relocate();\n        drive_goto(-25, 26);\n        //drive_goto(SIDE * cmToTicks, SIDE * cmToTicks);\n        moveDist();\n    }\n\n    //relocate();\n    drive_goto(51, -51);\n    currentDirection = NORTH;\n\n    // Blink LED\n    for (int i = 0; i < 3; i++) {\n        high(26);\n        pause(250);\n        low(26);\n        pause(250);\n    }\n\n    //drive_goto(cmToTicks * SIDE, cmToTicks * SIDE);\n\n    // optimal path\n    drive_speed(finalSpeed, finalSpeed);\n    move(finalArray, 0, lengthArr);\n    drive_speed(0, 0);\n}\n","defaultMarkerLayerId":"0","markerLayers":{"0":{"id":"0","maintainHistory":false,"markersById":{},"version":2},"1":{"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"id":"2","maintainHistory":true,"markersById":{"1":{"range":{"start":{"row":3,"column":0},"end":{"row":3,"column":0}},"properties":{"type":"selection","goalScreenRange":null,"autoscroll":false,"preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2},"4":{"id":"4","maintainHistory":false,"markersById":{},"version":2},"5":{"id":"5","maintainHistory":false,"markersById":{},"version":2},"7":{"id":"7","maintainHistory":false,"markersById":{},"version":2},"9":{"id":"9","maintainHistory":false,"markersById":{},"version":2}},"nextMarkerLayerId":10,"history":{"version":3,"nextCheckpointId":5,"undoStack":[{"type":"group-start","snapshot":{"2":{"1":{"range":[[16,17],[16,17]],"properties":{"type":"selection","goalScreenRange":null,"autoscroll":false},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}}}},{"type":"change","content":{"oldRange":[[16,17],[16,17]],"newRange":[[16,17],[17,0]],"oldText":"","newText":"\n"}},{"type":"change","content":{"oldRange":[[17,0],[17,0]],"newRange":[[17,0],[17,0]],"oldText":"","newText":""}},{"type":"group-end","snapshot":{"2":{"1":{"range":[[17,0],[17,0]],"properties":{"type":"selection","goalScreenRange":null,"autoscroll":false},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}}}}],"redoStack":[]},"encoding":"utf8","filePath":"/home/anirudh/Desktop/rob/combined.c","digestWhenLastPersisted":"9e3089d67589eaf8620e981ad75bba267c8379ba","preferredLineEnding":null,"nextMarkerId":30,"deserializer":"TextBuffer","version":5},{"id":"63b46d790e98595c0b7f9c55a2eadf04","text":"#include \"simpletools.h\"          // Include simpletools header\n#include \"ping.h\"                 // Include ping header\n#include \"abdrive.h\"              // Include abdrive header\n\n\n#define SIDE 40\n#define NORTH 0\n#define EAST 1\n#define SOUTH 2\n#define WEST 3\n#define cmToTicks (1 / 0.325)\n#define idealDist 15\n#define minDiff 2\n\n// default speed of the robot\n#define speed 50\n#define finalSpeed 128\n\n#define reduce 450\n#define TURN 750\n#define STOP 960\n\n// factor by which speed of wheel changes to make a turn\n#define factor 2\n\n// A node in the linked list\ntypedef struct Node {\n    struct Node *next;\n    struct Node *prev;\n    int nodeNumber;\n} Node;\n\n\n// Stores head, tail and number of nodes in the linked list\ntypedef struct List {\n    struct Node *first;\n    struct Node *last;\n    int numberOfNodes;\n} List;\n\n\nList *list;\nList *listRev;\n\n// Defining global Variables\nint currentNode = 1;\nint destination;\nint currentDirection = NORTH;\nint lengthArr;\n\n\nint leftDist, rightDist;\nint leftTicksOld = 0, rightTicksOld = 0;\nint leftTicks = 0, rightTicks = 0;\n\n\n// Get the values from the right and left sensors\nvoid irDist() {\n\n    leftDist = 0;\n    rightDist = 0;\n\n    for(int dacVal = 0; dacVal < 160; dacVal += 8) {\n        dac_ctr(26, 0, dacVal);\n        freqout(11, 1, 38000);\n        leftDist += input(10);\n\n        dac_ctr(27, 1, dacVal);\n        freqout(1, 1, 38000);\n        rightDist += input(2);\n    }\n\n   print(\"leftDist: %d\\trightDist: %d\\n\", leftDist, rightDist);\n}\n\n// Function to move the robot\nvoid moveRobot() {\n\n    int distError;\n\n    if(leftDist < 20 && rightDist < 20 && ((leftDist - rightDist) >= minDiff || (leftDist - rightDist) <= -minDiff)) {\n        distError = leftDist - rightDist;\n    } else if (rightDist < 20 && leftDist == 20 && ((idealDist - rightDist) >= minDiff || (idealDist - rightDist) <= -minDiff)) {\n        distError = idealDist - rightDist;\n    } else if (rightDist == 20 && leftDist < 20 && ((leftDist - idealDist) >= minDiff || (leftDist - idealDist) <= -minDiff)) {\n        distError = leftDist - idealDist;\n    } else {\n        distError = 0;\n    }\n\n    distError *= factor;\n    print(\"distError : %d\\n\", distError);\n    if(distError < 0) {\n        drive_speed(speed - distError, speed);\n    } else {\n        drive_speed(speed, speed + distError);\n    }\n    //drive_speed(speed - distError, speed + distError);\n}\n\n\nvoid moveDist() {\n    drive_getTicks(&leftTicks, &rightTicks);\n    leftTicksOld = leftTicks;\n    rightTicksOld = rightTicks;\n    while((leftTicks - leftTicksOld < (SIDE * cmToTicks)) && (rightTicks - rightTicksOld < (SIDE * cmToTicks)) && (ping_cm > 6)) {\n        irDist();\n        moveRobot();\n        drive_getTicks(&leftTicks, &rightTicks);\n        //print(\"new - %d \\t old - %d\\n\", leftTicks, leftTicksOld);\n    }\n    drive_speed(0, 0);\n}\n\n\n\nvoid turn(char* str){\n    if(str == \"left\"){\n        switch (currentDirection) {\n            case NORTH:\n            currentDirection = WEST;\n            break;\n            case WEST:\n            currentDirection = SOUTH;\n            break;\n            case SOUTH:\n            currentDirection = EAST;\n            break;\n            default:\n            currentDirection = NORTH;\n        }\n    } else {\n        switch (currentDirection) {\n            case NORTH:\n            currentDirection = EAST;\n            break;\n            case EAST:\n            currentDirection = SOUTH;\n            break;\n            case SOUTH:\n            currentDirection = WEST;\n            break;\n            default:\n            currentDirection = NORTH;\n        }\n    }\n}\n\nint lengthLL(List *temp) {\n    Node *head = temp -> first;\n    int len = 0;\n    while(head != NULL) {\n        len++;\n        head = head -> next;\n    }\n    return len;\n}\n\nvoid cutLL(List *list1) {\n    int length = lengthLL(list1);\n    Node *temp1 = list1 -> first;\n    for(int i = 0; temp1 != NULL; i++) {\n        Node *temp2 = temp1 -> next;\n        for(int j = i + 1; temp2 != NULL; j++) {\n            if(temp1 -> nodeNumber == temp2 -> nodeNumber) {\n                temp1 -> next = temp2 -> next;\n            }\n            temp2 = temp2 -> next;\n        }\n        temp1 = temp1 -> next;\n    }\n}\n\nvoid displayArray(int *arr) {\n    for(int i = 0; i < lengthArr; i++) {\n        print(\"%d : \", arr[i]);\n    }\n    print(\"\\n\");\n}\n\nint* LLtoArray(List *list1) {\n    lengthArr = lengthLL(list1) + 1;\n    Node *temp = list1 -> first;\n    int *arr = (int*) malloc (sizeof(int) * lengthArr);\n    arr[0] = -3;\n    for(int i = 1; i < lengthArr; i++) {\n        arr[i] = temp -> nodeNumber;\n        temp = temp -> next;\n    }\n\n    displayArray(arr);\n\n    return arr;\n}\n\n\nvoid printLL(List *temp) {\n    Node *node = temp -> first;\n    if(node == NULL) {\n        //print(\"List empty\");\n        return;\n    }\n    while(node != NULL) {\n        //print(\"%d --> \", node -> nodeNumber);\n        node = node -> next;\n    }\n    //print(\"\\n\");\n}\n\n\n// Add nodes to the linked list\nvoid prependNode() {\n    Node *node = (Node*)malloc(sizeof(Node));\n    node -> next = NULL;\n    node -> prev = NULL;\n    node -> nodeNumber = currentNode;\n    if (listRev -> last == NULL) {\n        listRev -> first = node;\n        listRev -> last = node;\n    } else {\n        node -> next = listRev -> first;\n        listRev -> first -> prev = node;\n        listRev -> first = node;\n    }\n    listRev -> numberOfNodes += 1;\n}\n\n\n// Add nodes to the linked list\nvoid appendNode() {\n    Node *node = (Node*)malloc(sizeof(Node));\n    node -> next = NULL;\n    node -> prev = NULL;\n    node -> nodeNumber = currentNode;\n    if (list -> first == NULL) {\n        list -> first = node;\n        list -> last = node;\n    } else {\n        list -> last -> next = node;\n        list -> last = node;\n    }\n    list -> numberOfNodes += 1;\n}\n\n\nvoid moveForward() {\n    switch(currentDirection) {\n        case NORTH:\n        currentNode += 4;\n        break;\n        case EAST:\n        currentNode += 1;\n        break;\n        case WEST:\n        currentNode -= 1;\n        break;\n        default:\n        currentNode -= 4;\n    }\n\n    print(\"current node: %d\\n\", currentNode);\n\n    if(destination == 16 || destination == 13)\n        appendNode();\n\n    if(destination == 1 || destination == 4)\n        prependNode();\n\n    //drive_goto(cmToTicks * SIDE, cmToTicks * SIDE);\n    moveDist();\n\n}\n\n\nvoid relocate() {\n    int pingDist = ping_cm(8);\n    ////print(\"%d\\n\", pingDist);\n    if(pingDist < 30) {\n        int diff = 18 - pingDist;\n        drive_goto(-(diff * cmToTicks), -(diff * cmToTicks));\n    }\n}\n\n\nvoid reachNode () {\n    while(currentNode != destination) {\n        //relocate();\n        //turn left to check\n        drive_goto(-25, 26);\n        //relocate();\n        if (ping_cm(8) >= 30) {\n            turn(\"left\");\n            moveForward();\n        } else {\n            //become straight\n            drive_goto(25, -26);\n            //relocate();\n            //if blocked then turn right\n            if(ping_cm(8) <= 30) {\n                drive_goto(25, -26);\n                //relocate();\n                turn(\"right\");\n                //if blocked then right\n                //going back\n                if(ping_cm(8) <= 30) {\n                    turn(\"right\");\n                    drive_goto(25, -25);\n                    moveForward();\n                }\n                //continue to rigth\n                else {\n                    moveForward();\n                }\n            }\n            //if not blocked then continue straight\n            else {\n                moveForward();\n            }\n        }\n    }\n}\n\nvoid turnDirection(int direction){\n  if(currentDirection == direction){\n    return;\n  }\n  //drive_speed(30, 30);\n  int diff = currentDirection - direction;\n\n  if (diff > 0){\n    drive_speed(60, 128);\n  } else {\n    drive_speed(128, 60);\n  }\n\n  pause(TURN * abs(diff));\n  currentDirection = direction;\n  drive_speed(128, 128);\n  return;\n}\n\nint checkNext(int input[], int index, int size){\n  if (index >= size - 1){\n    return -10;\n  }\n\n  int curr = input[index];\n  int target = input[index + 1];\n  int diff = target - curr;\n  //print(\"%d\\n\", diff);\n  return diff;\n}\n\n\nint numOfTurns(int input[], int size){\n  int i = 0;\n  int turns = 0;\n  int last = 4;\n  for(i = 0; i < size; i++){\n    if (checkNext(input, i, size) != last){\n      turns++;\n      last = checkNext(input, i, size);\n    }\n  }\n  print(\"%d \\n\", turns);\n  return turns;\n}\n\nint check = 0;\n\n\nvoid move(int input[], int index, int sizeOfInput){\n\n  check++;\n\n  int diff = checkNext(input, index, sizeOfInput);\n\n  if(diff == -10){\n    drive_speed(0, 0);\n    return;\n  }\n\n  int counter = 0;\n  //print(\"%i\\n\", counter);\n\n  switch (diff){\n    //move right until diff is 1\n    case 1:\n      turnDirection(EAST);\n      counter = 0;\n      while(diff == 1){\n        ++index;\n        counter++;\n        diff = checkNext(input, index, sizeOfInput);\n        //print(\"hi\");\n      }\n      drive_speed(finalSpeed, finalSpeed);\n      if (check == 1 || check == numOfTurns(input, sizeOfInput)){\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce));\n        pause((counter - 0.35) * STOP);\n      } else {\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - (reduce * 2)));\n        pause((counter - 0.8) * STOP);\n      }\n      break;\n    //move left until diff is -1\n    case -1:\n      turnDirection(WEST);\n      counter = 0;\n      while(diff == -1){\n        ++index;\n        counter++;\n        diff = checkNext(input, index, sizeOfInput);\n        //print(\"hi\");\n      }\n      drive_speed(finalSpeed, finalSpeed);\n      if (check == 1 || check == numOfTurns(input, sizeOfInput)){\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce));\n        pause((counter - 0.35) * STOP);\n      } else {\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce - reduce));\n        pause((counter - 0.8) * STOP);\n      }\n      break;\n    //move forward until diff is 4\n    case 4:\n      turnDirection(NORTH);\n      counter = 0;\n      while(diff == 4){\n        ++index;\n        counter++;\n        diff = checkNext(input, index, sizeOfInput);\n        //print(\"hi\");\n      }\n      drive_speed(finalSpeed, finalSpeed);\n      if (check == 1 || check == numOfTurns(input, sizeOfInput)){\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce));\n        pause((counter - 0.35) * STOP);\n      } else {\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce - reduce));\n        pause((counter - 0.8) * STOP);\n      }\n      break;\n    //move backwards until diff is -4\n    default:\n      turnDirection(SOUTH);\n      counter = 0;\n      while(diff == -4){\n        ++index;\n        counter++;\n        diff = checkNext(input, index, sizeOfInput);\n        //print(\"hi\");\n      }\n      drive_speed(finalSpeed, finalSpeed);\n      if (check == 1 || check == numOfTurns(input, sizeOfInput)){\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce));\n        pause((counter - 0.35) * STOP);\n      } else {\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce - reduce));\n        pause((counter - 0.8) * STOP);\n      }\n  }\n  //print(\"%i\\n\", counter);\n  move(input, index, sizeOfInput);\n}\n\nvoid freeList(List *list1) {\n    Node *temp1 = list1 -> first;\n    Node *temp2 = temp1 -> next;\n    while(temp1 != list1 -> last) {\n        //print(\"%d freed\\n\", temp1 -> nodeNumber);\n        free(temp1);\n        temp1 = temp2;\n        temp2 = temp1 -> next;\n    }\n\n    free(temp1);\n}\n\n\nint main() {\n\n    list = malloc(sizeof(List));\n    list -> first = NULL;\n    list -> last = NULL;\n    list -> numberOfNodes = 0;\n\n    listRev = malloc(sizeof(List));\n    listRev -> first = NULL;\n    listRev -> last = NULL;\n    listRev -> numberOfNodes = 0;\n\n    drive_goto(cmToTicks * SIDE / 4, cmToTicks * SIDE / 4);\n    moveDist();\n    print(\"current node: %d\\n\", currentNode);\n\n    appendNode();\n\n    destination = 13;\n    reachNode();\n    //printLL(list);\n\n    destination = 16;\n    reachNode();\n    //printLL(list);\n\n    prependNode();\n\n    destination = 4;\n    reachNode();\n    //printLL(listRev);\n\n    destination = 1;\n    reachNode();\n    //printLL(listRev);\n\n    cutLL(list);\n    cutLL(listRev);\n\n    int *finalArray;\n    int len;\n\n    if(lengthLL(list) <= lengthLL(listRev)) {\n        finalArray = LLtoArray(list);\n    } else {\n        finalArray = LLtoArray(listRev);\n    }\n\n    freeList(list);\n    freeList(listRev);\n\n    if (ping_cm(8) >= 30) {\n        // drive_goto(SIDE * cmToTicks, SIDE * cmToTicks);\n        moveDist();\n    } else {\n        //relocate();\n        drive_goto(-25, 26);\n        //drive_goto(SIDE * cmToTicks, SIDE * cmToTicks);\n        moveDist();\n    }\n\n    //relocate();\n    drive_goto(51, -51);\n    currentDirection = NORTH;\n\n    // Blink LED\n    for (int i = 0; i < 3; i++) {\n        high(26);\n        pause(250);\n        low(26);\n        pause(250);\n    }\n\n    //drive_goto(cmToTicks * SIDE, cmToTicks * SIDE);\n\n    // optimal path\n    drive_speed(finalSpeed, finalSpeed);\n    move(finalArray, 0, lengthArr);\n    drive_speed(0, 0);\n}\n","defaultMarkerLayerId":"0","markerLayers":{"0":{"id":"0","maintainHistory":false,"markersById":{},"version":2},"1":{"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"id":"2","maintainHistory":true,"markersById":{"1":{"range":{"start":{"row":61,"column":0},"end":{"row":61,"column":0}},"properties":{"type":"selection","goalScreenRange":null,"autoscroll":false,"preserveFolds":true},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2},"4":{"id":"4","maintainHistory":false,"markersById":{},"version":2},"5":{"id":"5","maintainHistory":false,"markersById":{},"version":2},"7":{"id":"7","maintainHistory":false,"markersById":{},"version":2}},"nextMarkerLayerId":8,"history":{"version":3,"nextCheckpointId":5,"undoStack":[{"type":"group-start","snapshot":{"2":{"1":{"range":[[0,0],[0,0]],"properties":{"type":"selection"},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}}}},{"type":"change","content":{"oldRange":[[0,0],[0,0]],"newRange":[[0,0],[559,1]],"oldText":"","newText":"#include \"simpletools.h\"          // Include simpletools header\n#include \"ping.h\"                 // Include ping header\n#include \"abdrive.h\"              // Include abdrive header\n\n\n#define SIDE 40\n#define NORTH 0\n#define EAST 1\n#define SOUTH 2\n#define WEST 3\n#define cmToTicks (1 / 0.325)\n#define idealDist 15\n#define minDiff 2\n\n// default speed of the robot\n#define speed 50\n#define finalSpeed 128\n\n#define reduce 450\n#define TURN 750\n#define STOP 960\n\n// factor by which speed of wheel changes to make a turn\n#define factor 2\n\n// A node in the linked list\ntypedef struct Node {\n    struct Node *next;\n    struct Node *prev;\n    int nodeNumber;\n} Node;\n\n\n// Stores head, tail and number of nodes in the linked list\ntypedef struct List {\n    struct Node *first;\n    struct Node *last;\n    int numberOfNodes;\n} List;\n\n\nList *list;\nList *listRev;\n\n// Defining global Variables\nint currentNode = 1;\nint destination;\nint currentDirection = NORTH;\nint lengthArr;\n\n\nint leftDist, rightDist;\nint leftTicksOld = 0, rightTicksOld = 0;\nint leftTicks = 0, rightTicks = 0;\n\n\n// Get the values from the right and left sensors\nvoid irDist() {\n\n    leftDist = 0;\n    rightDist = 0;\n\n    for(int dacVal = 0; dacVal < 160; dacVal += 8) {\n        dac_ctr(26, 0, dacVal);\n        freqout(11, 1, 38000);\n        leftDist += input(10);\n\n        dac_ctr(27, 1, dacVal);\n        freqout(1, 1, 38000);\n        rightDist += input(2);\n    }\n\n   print(\"leftDist: %d\\trightDist: %d\\n\", leftDist, rightDist);\n}\n\n// Function to move the robot\nvoid moveRobot() {\n\n    int distError;\n\n    if(leftDist < 20 && rightDist < 20 && ((leftDist - rightDist) >= minDiff || (leftDist - rightDist) <= -minDiff)) {\n        distError = leftDist - rightDist;\n    } else if (rightDist < 20 && leftDist == 20 && ((idealDist - rightDist) >= minDiff || (idealDist - rightDist) <= -minDiff)) {\n        distError = idealDist - rightDist;\n    } else if (rightDist == 20 && leftDist < 20 && ((leftDist - idealDist) >= minDiff || (leftDist - idealDist) <= -minDiff)) {\n        distError = leftDist - idealDist;\n    } else {\n        distError = 0;\n    }\n\n    distError *= factor;\n    print(\"distError : %d\\n\", distError);\n    if(distError < 0) {\n        drive_speed(speed - distError, speed);\n    } else {\n        drive_speed(speed, speed + distError);\n    }\n    //drive_speed(speed - distError, speed + distError);\n}\n\n\nvoid moveDist() {\n    drive_getTicks(&leftTicks, &rightTicks);\n    leftTicksOld = leftTicks;\n    rightTicksOld = rightTicks;\n    while((leftTicks - leftTicksOld < (SIDE * cmToTicks)) && (rightTicks - rightTicksOld < (SIDE * cmToTicks)) && (ping_cm > 6)) {\n        irDist();\n        moveRobot();\n        drive_getTicks(&leftTicks, &rightTicks);\n        //print(\"new - %d \\t old - %d\\n\", leftTicks, leftTicksOld);\n    }\n    drive_speed(0, 0);\n}\n\n\n\nvoid turn(char* str){\n    if(str == \"left\"){\n        switch (currentDirection) {\n            case NORTH:\n            currentDirection = WEST;\n            break;\n            case WEST:\n            currentDirection = SOUTH;\n            break;\n            case SOUTH:\n            currentDirection = EAST;\n            break;\n            default:\n            currentDirection = NORTH;\n        }\n    } else {\n        switch (currentDirection) {\n            case NORTH:\n            currentDirection = EAST;\n            break;\n            case EAST:\n            currentDirection = SOUTH;\n            break;\n            case SOUTH:\n            currentDirection = WEST;\n            break;\n            default:\n            currentDirection = NORTH;\n        }\n    }\n}\n\nint lengthLL(List *temp) {\n    Node *head = temp -> first;\n    int len = 0;\n    while(head != NULL) {\n        len++;\n        head = head -> next;\n    }\n    return len;\n}\n\nvoid cutLL(List *list1) {\n    int length = lengthLL(list1);\n    Node *temp1 = list1 -> first;\n    for(int i = 0; temp1 != NULL; i++) {\n        Node *temp2 = temp1 -> next;\n        for(int j = i + 1; temp2 != NULL; j++) {\n            if(temp1 -> nodeNumber == temp2 -> nodeNumber) {\n                temp1 -> next = temp2 -> next;\n            }\n            temp2 = temp2 -> next;\n        }\n        temp1 = temp1 -> next;\n    }\n}\n\nvoid displayArray(int *arr) {\n    for(int i = 0; i < lengthArr; i++) {\n        print(\"%d : \", arr[i]);\n    }\n    print(\"\\n\");\n}\n\nint* LLtoArray(List *list1) {\n    lengthArr = lengthLL(list1) + 1;\n    Node *temp = list1 -> first;\n    int *arr = (int*) malloc (sizeof(int) * lengthArr);\n    arr[0] = -3;\n    for(int i = 1; i < lengthArr; i++) {\n        arr[i] = temp -> nodeNumber;\n        temp = temp -> next;\n    }\n\n    displayArray(arr);\n\n    return arr;\n}\n\n\nvoid printLL(List *temp) {\n    Node *node = temp -> first;\n    if(node == NULL) {\n        //print(\"List empty\");\n        return;\n    }\n    while(node != NULL) {\n        //print(\"%d --> \", node -> nodeNumber);\n        node = node -> next;\n    }\n    //print(\"\\n\");\n}\n\n\n// Add nodes to the linked list\nvoid prependNode() {\n    Node *node = (Node*)malloc(sizeof(Node));\n    node -> next = NULL;\n    node -> prev = NULL;\n    node -> nodeNumber = currentNode;\n    if (listRev -> last == NULL) {\n        listRev -> first = node;\n        listRev -> last = node;\n    } else {\n        node -> next = listRev -> first;\n        listRev -> first -> prev = node;\n        listRev -> first = node;\n    }\n    listRev -> numberOfNodes += 1;\n}\n\n\n// Add nodes to the linked list\nvoid appendNode() {\n    Node *node = (Node*)malloc(sizeof(Node));\n    node -> next = NULL;\n    node -> prev = NULL;\n    node -> nodeNumber = currentNode;\n    if (list -> first == NULL) {\n        list -> first = node;\n        list -> last = node;\n    } else {\n        list -> last -> next = node;\n        list -> last = node;\n    }\n    list -> numberOfNodes += 1;\n}\n\n\nvoid moveForward() {\n    switch(currentDirection) {\n        case NORTH:\n        currentNode += 4;\n        break;\n        case EAST:\n        currentNode += 1;\n        break;\n        case WEST:\n        currentNode -= 1;\n        break;\n        default:\n        currentNode -= 4;\n    }\n\n    print(\"current node: %d\\n\", currentNode);\n\n    if(destination == 16 || destination == 13)\n        appendNode();\n\n    if(destination == 1 || destination == 4)\n        prependNode();\n\n    //drive_goto(cmToTicks * SIDE, cmToTicks * SIDE);\n    moveDist();\n\n}\n\n\nvoid relocate() {\n    int pingDist = ping_cm(8);\n    ////print(\"%d\\n\", pingDist);\n    if(pingDist < 30) {\n        int diff = 18 - pingDist;\n        drive_goto(-(diff * cmToTicks), -(diff * cmToTicks));\n    }\n}\n\n\nvoid reachNode () {\n    while(currentNode != destination) {\n        //relocate();\n        //turn left to check\n        drive_goto(-25, 26);\n        //relocate();\n        if (ping_cm(8) >= 30) {\n            turn(\"left\");\n            moveForward();\n        } else {\n            //become straight\n            drive_goto(25, -26);\n            //relocate();\n            //if blocked then turn right\n            if(ping_cm(8) <= 30) {\n                drive_goto(25, -26);\n                //relocate();\n                turn(\"right\");\n                //if blocked then right\n                //going back\n                if(ping_cm(8) <= 30) {\n                    turn(\"right\");\n                    drive_goto(25, -25);\n                    moveForward();\n                }\n                //continue to rigth\n                else {\n                    moveForward();\n                }\n            }\n            //if not blocked then continue straight\n            else {\n                moveForward();\n            }\n        }\n    }\n}\n\nvoid turnDirection(int direction){\n  if(currentDirection == direction){\n    return;\n  }\n  //drive_speed(30, 30);\n  int diff = currentDirection - direction;\n\n  if (diff > 0){\n    drive_speed(60, 128);\n  } else {\n    drive_speed(128, 60);\n  }\n\n  pause(TURN * abs(diff));\n  currentDirection = direction;\n  drive_speed(128, 128);\n  return;\n}\n\nint checkNext(int input[], int index, int size){\n  if (index >= size - 1){\n    return -10;\n  }\n\n  int curr = input[index];\n  int target = input[index + 1];\n  int diff = target - curr;\n  //print(\"%d\\n\", diff);\n  return diff;\n}\n\n\nint numOfTurns(int input[], int size){\n  int i = 0;\n  int turns = 0;\n  int last = 4;\n  for(i = 0; i < size; i++){\n    if (checkNext(input, i, size) != last){\n      turns++;\n      last = checkNext(input, i, size);\n    }\n  }\n  print(\"%d \\n\", turns);\n  return turns;\n}\n\nint check = 0;\n\n\nvoid move(int input[], int index, int sizeOfInput){\n\n  check++;\n\n  int diff = checkNext(input, index, sizeOfInput);\n\n  if(diff == -10){\n    drive_speed(0, 0);\n    return;\n  }\n\n  int counter = 0;\n  //print(\"%i\\n\", counter);\n\n  switch (diff){\n    //move right until diff is 1\n    case 1:\n      turnDirection(EAST);\n      counter = 0;\n      while(diff == 1){\n        ++index;\n        counter++;\n        diff = checkNext(input, index, sizeOfInput);\n        //print(\"hi\");\n      }\n      drive_speed(finalSpeed, finalSpeed);\n      if (check == 1 || check == numOfTurns(input, sizeOfInput)){\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce));\n        pause((counter - 0.35) * STOP);\n      } else {\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - (reduce * 2)));\n        pause((counter - 0.8) * STOP);\n      }\n      break;\n    //move left until diff is -1\n    case -1:\n      turnDirection(WEST);\n      counter = 0;\n      while(diff == -1){\n        ++index;\n        counter++;\n        diff = checkNext(input, index, sizeOfInput);\n        //print(\"hi\");\n      }\n      drive_speed(finalSpeed, finalSpeed);\n      if (check == 1 || check == numOfTurns(input, sizeOfInput)){\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce));\n        pause((counter - 0.35) * STOP);\n      } else {\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce - reduce));\n        pause((counter - 0.8) * STOP);\n      }\n      break;\n    //move forward until diff is 4\n    case 4:\n      turnDirection(NORTH);\n      counter = 0;\n      while(diff == 4){\n        ++index;\n        counter++;\n        diff = checkNext(input, index, sizeOfInput);\n        //print(\"hi\");\n      }\n      drive_speed(finalSpeed, finalSpeed);\n      if (check == 1 || check == numOfTurns(input, sizeOfInput)){\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce));\n        pause((counter - 0.35) * STOP);\n      } else {\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce - reduce));\n        pause((counter - 0.8) * STOP);\n      }\n      break;\n    //move backwards until diff is -4\n    default:\n      turnDirection(SOUTH);\n      counter = 0;\n      while(diff == -4){\n        ++index;\n        counter++;\n        diff = checkNext(input, index, sizeOfInput);\n        //print(\"hi\");\n      }\n      drive_speed(finalSpeed, finalSpeed);\n      if (check == 1 || check == numOfTurns(input, sizeOfInput)){\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce));\n        pause((counter - 0.35) * STOP);\n      } else {\n        print(\"%d \\t %d\\n\", (counter * STOP), (counter * STOP - reduce - reduce));\n        pause((counter - 0.8) * STOP);\n      }\n  }\n  //print(\"%i\\n\", counter);\n  move(input, index, sizeOfInput);\n}\n\nvoid freeList(List *list1) {\n    Node *temp1 = list1 -> first;\n    Node *temp2 = temp1 -> next;\n    while(temp1 != list1 -> last) {\n        //print(\"%d freed\\n\", temp1 -> nodeNumber);\n        free(temp1);\n        temp1 = temp2;\n        temp2 = temp1 -> next;\n    }\n\n    free(temp1);\n}\n\n\nint main() {\n\n    list = malloc(sizeof(List));\n    list -> first = NULL;\n    list -> last = NULL;\n    list -> numberOfNodes = 0;\n\n    listRev = malloc(sizeof(List));\n    listRev -> first = NULL;\n    listRev -> last = NULL;\n    listRev -> numberOfNodes = 0;\n\n    drive_goto(cmToTicks * SIDE / 4, cmToTicks * SIDE / 4);\n    moveDist();\n    print(\"current node: %d\\n\", currentNode);\n\n    appendNode();\n\n    destination = 13;\n    reachNode();\n    //printLL(list);\n\n    destination = 16;\n    reachNode();\n    //printLL(list);\n\n    prependNode();\n\n    destination = 4;\n    reachNode();\n    //printLL(listRev);\n\n    destination = 1;\n    reachNode();\n    //printLL(listRev);\n\n    cutLL(list);\n    cutLL(listRev);\n\n    int *finalArray;\n    int len;\n\n    if(lengthLL(list) <= lengthLL(listRev)) {\n        finalArray = LLtoArray(list);\n    } else {\n        finalArray = LLtoArray(listRev);\n    }\n\n    freeList(list);\n    freeList(listRev);\n\n    if (ping_cm(8) >= 30) {\n        // drive_goto(SIDE * cmToTicks, SIDE * cmToTicks);\n        moveDist();\n    } else {\n        //relocate();\n        drive_goto(-25, 26);\n        //drive_goto(SIDE * cmToTicks, SIDE * cmToTicks);\n        moveDist();\n    }\n\n    //relocate();\n    drive_goto(51, -51);\n    currentDirection = NORTH;\n\n    // Blink LED\n    for (int i = 0; i < 3; i++) {\n        high(26);\n        pause(250);\n        low(26);\n        pause(250);\n    }\n\n    //drive_goto(cmToTicks * SIDE, cmToTicks * SIDE);\n\n    // optimal path\n    drive_speed(finalSpeed, finalSpeed);\n    move(finalArray, 0, lengthArr);\n    drive_speed(0, 0);\n}"}},{"type":"change","content":{"oldRange":[[0,0],[0,0]],"newRange":[[0,0],[0,0]],"oldText":"","newText":""}},{"type":"group-end","snapshot":{"2":{"1":{"range":[[559,1],[559,1]],"properties":{"type":"selection","goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}}}},{"type":"group-start","snapshot":{"2":{"1":{"range":[[559,1],[559,1]],"properties":{"type":"selection","goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}}}},{"type":"change","content":{"oldRange":[[559,1],[559,1]],"newRange":[[559,1],[560,0]],"oldText":"","newText":"\n"}},{"type":"group-end","snapshot":{"2":{"1":{"range":[[559,1],[559,1]],"properties":{"type":"selection","goalScreenRange":null},"reversed":false,"tailed":true,"valid":true,"invalidate":"never"}}}}],"redoStack":[]},"encoding":"utf8","filePath":"/home/anirudh/Desktop/rob/final.c","digestWhenLastPersisted":"b95ece219d715a1b87c2332293b395f16c4169a9","preferredLineEnding":"\n","nextMarkerId":201,"deserializer":"TextBuffer","version":5}]},"workspace":{"deserializer":"Workspace","paneContainer":{"deserializer":"PaneContainer","version":1,"root":{"deserializer":"Pane","id":3,"items":[{"deserializer":"TextEditor","id":364,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":365,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/home/anirudh/Desktop/rob/newsmooth.c","bufferId":"18abca5ccb0cbb15ef946c00561405b4","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"},{"deserializer":"TextEditor","id":418,"softTabs":true,"firstVisibleScreenRow":0,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":419,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/home/anirudh/Desktop/rob/combined.c","bufferId":"b5167922c51c816dada0dc77581874a2","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"},{"deserializer":"TextEditor","id":430,"softTabs":true,"firstVisibleScreenRow":59,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":431,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/home/anirudh/Desktop/rob/final.c","bufferId":"63b46d790e98595c0b7f9c55a2eadf04","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"}],"activeItemURI":"/home/anirudh/Desktop/rob/final.c","focused":true,"flexScale":1},"activePaneId":3},"packagesWithActiveGrammars":["language-c","language-hyperlink","language-todo"],"destroyedItemURIs":["/home/anirudh/Desktop/rob/pair57_task4/4.2.c","/home/anirudh/Desktop/rob/pair57_task4/task-methods.h","/home/anirudh/Desktop/rob/pair57_task5_midTermTask/midTermTask.c","/home/anirudh/Desktop/rob/pair57_task4/task-methods.c","/home/anirudh/Desktop/rob/pair57_task4/4.1.c","/home/anirudh/Desktop/rob/4.2.c","atom://config/updates","/home/anirudh/Desktop/rob/testMover.c","/home/anirudh/Desktop/rob/run.txt","/home/anirudh/Desktop/rob/wall-follower.c","/home/anirudh/Desktop/rob/wall.c","/home/anirudh/Desktop/rob/finalAni.txt","/home/anirudh/Desktop/rob/maze.c","/home/anirudh/Desktop/rob/combine.c","/home/anirudh/Desktop/rob/newmove.c","/home/anirudh/Desktop/rob/stest.c","/home/anirudh/Desktop/rob/move.c","/home/anirudh/Desktop/rob/newcomb.c","/home/anirudh/Desktop/rob/speed.c","/home/anirudh/Desktop/rob/faster.c","/home/anirudh/Downloads/finalSpeed.txt","/home/anirudh/Desktop/rob/new.c","/home/anirudh/Desktop/rob/test.c","/home/anirudh/Downloads/smooth.txt","/home/anirudh/Desktop/rob/smooth.c","/home/anirudh/Desktop/rob/finalSpeed.txt","/home/anirudh/Desktop/rob/smooth.txt","/home/anirudh/Desktop/rob/finalSpeed.c","/home/anirudh/Downloads/finalLeft.txt"]},"packageStates":{"find-and-replace":{"findOptions":{"findPattern":"TURN","replacePattern":"","pathsPattern":"","useRegex":false,"wholeWord":false,"caseSensitive":true,"inCurrentSelection":false},"findHistory":["leftTicks","rightTicks","accRate_right","ticks","SQUARE_LENGTH","SIDE","relo","array","Array","LLtoArray","turnDirection","SIDE","TURN","turn","TURN"],"replaceHistory":["SIDE"],"pathsHistory":[]},"fuzzy-finder":{"/home/anirudh/Desktop/rob/newsmooth.c":1464605035779,"/home/anirudh/Desktop/rob/combined.c":1464806905800,"/home/anirudh/Desktop/rob/final.c":1464881675702},"keybinding-resolver":{},"metrics":{"sessionLength":10546453},"tree-view":{"directoryExpansionStates":{"/home/anirudh/Desktop/rob":{"isExpanded":true,"entries":{}}},"selectedPath":"/home/anirudh/Desktop/rob/final.c","hasFocus":false,"attached":true,"scrollLeft":0,"scrollTop":0,"width":276}},"fullScreen":false}