{"version":1,"windowDimensions":{"x":0,"y":19,"width":1366,"height":749,"maximized":false},"grammars":{"grammarOverridesByPath":{}},"project":{"deserializer":"Project","paths":["/home/anirudh/Desktop/uclcode/C/Robotics"],"buffers":[{"id":"56cc81ef9bc6182fee9e53387f5a697a","text":"#include \"simpletools.h\"\n#include \"abdrive.h\"\n#include \"ping.h\"\n\nint irLeft, irRight; // for IR sensors\nint pingDistance; // for Ping))), distance from the wall\n\nint leftDistance = 0;\nint rightDistance = 0;\n\nint multiplier = 5;\nint targetDistLeft = 5;\n\nfloat x;\nfloat y;\n\nint width = 106;\n\nint max(int left, int right){\n  if(left > right){\n    return left;\n  } else {\n    return right;\n  }\n}\n\nint min(int left, int right){\n  if(left > right){\n    return right;\n  } else {\n    return left;\n  }\n}\n\nfloat getAngle(int left, int right){\n  int maxv = max(left, right);\n  int minv = min(left, right);\n  float ret = (maxv - minv) / width;\n  print(\"ret %f\", ret);\n  return ret;\n}\n\nfloat finalAngle(int adjacent, int opposite){\n  return atan(opposite/ adjacent);\n}\n\n// reading Ping))), GIVEN\nvoid pingSensor() {\n    pingDistance = ping_cm(8);\n}\n\n// reading IR sensors, GIVEN\nvoid irOutputState()\n{\n    irLeft = 0;\n    irRight = 0;\n\n    for(int dacVal = 0; dacVal < 160; dacVal += 8) {\n      dac_ctr(26, 0, dacVal);\n      freqout(11, 1, 38000);\n      irLeft += input(10);\n\n      dac_ctr(27, 1, dacVal);\n      freqout(1, 1, 38000);\n      irRight += input(2);\n    }\n}\n\ntypedef struct Node {\n  float left;\n  float right;\n  struct Node *prev;\n} Node;\n\nNode *head;\n\nNode* newNode(float left, float right) {\n    Node *node = (Node *) malloc(sizeof(Node));\n    node->left = left;\n    node->right = right;\n    node->prev = NULL;\n    return node;\n}\n\nvoid insert(float left, float right) {\n\tNode *node = newNode(left, right);\n\tnode->prev = head;\n   head = node;\n}\n\nvoid printList(){\n  Node *temp = head;\n  while(temp != NULL){\n    print(\"%d %d\", temp->left, temp->right);\n    temp = temp->prev;\n  }\n}\n\nint main()\n{\n  head = NULL;\n  drive_getTicks(&leftDistance, &rightDistance);\n\n  //while(pingDistance > 15) {\n  while(1){\n    irOutputState();\n\n    int difference = multiplier * (irLeft - targetDistLeft);\n    drive_rampStep(16 - difference, 16 + difference);\n\n    int currLeft = leftDistance;\n    int currRight = rightDistance;\n\n    drive_getTicks(&leftDistance, &rightDistance);\n    int leftDiff = leftDistance - currLeft;\n    int rightDiff = rightDistance - currRight;\n    \n    print(\"leftDiff %d rightDiff %d \\n\", leftDiff, rightDiff);\n\n    insert(leftDiff, rightDiff);\n\n    float rm = (leftDiff + rightDiff) / 2;\n    print(\"rm %f\\n\", rm);\n    print(\"cos %f\\n\", cos(getAngle(leftDiff, rightDiff)));\n\n    float xChange = rm - rm * cos(getAngle(leftDiff, rightDiff));\n    float yChange = rm * sin(getAngle(leftDiff, rightDiff));\n\n    print(\"xChange %f yChange %f \\n\", xChange, yChange);\n    x += xChange;\n    y += yChange;\n    pause(2000);\n  }\n\n  float fa = finalAngle(x, y);\n  //print(\"x %f y %f angle %f \\n\", x, y, fa);\n  drive_speed(0,0);\n  printList();\n}\n","defaultMarkerLayerId":"0","markerLayers":{"0":{"id":"0","maintainHistory":false,"markersById":{},"version":2},"1":{"id":"1","maintainHistory":false,"markersById":{},"version":2},"2":{"id":"2","maintainHistory":true,"markersById":{"1":{"range":{"start":{"row":124,"column":0},"end":{"row":124,"column":0}},"properties":{"type":"selection","goalScreenRange":null},"reversed":false,"tailed":false,"valid":true,"invalidate":"never"}},"version":2},"4":{"id":"4","maintainHistory":false,"markersById":{},"version":2}},"nextMarkerLayerId":5,"history":{"version":3,"nextCheckpointId":1,"undoStack":[],"redoStack":[]},"encoding":"utf8","filePath":"/home/anirudh/Desktop/uclcode/C/Robotics/midterm-task.c","digestWhenLastPersisted":"5daae87e9a8b2fb4f921f3835ad2dd81948c62b7","preferredLineEnding":null,"nextMarkerId":2,"deserializer":"TextBuffer","version":5}]},"workspace":{"deserializer":"Workspace","paneContainer":{"deserializer":"PaneContainer","version":1,"root":{"deserializer":"Pane","id":3,"items":[{"deserializer":"TextEditor","id":108,"softTabs":true,"firstVisibleScreenRow":109,"firstVisibleScreenColumn":0,"displayBuffer":{"deserializer":"DisplayBuffer","id":109,"softWrapped":false,"tokenizedBuffer":{"deserializer":"TokenizedBuffer","bufferPath":"/home/anirudh/Desktop/uclcode/C/Robotics/midterm-task.c","bufferId":"56cc81ef9bc6182fee9e53387f5a697a","largeFileMode":false},"largeFileMode":false,"foldsMarkerLayerId":"1"},"selectionsMarkerLayerId":"2"}],"activeItemURI":"/home/anirudh/Desktop/uclcode/C/Robotics/midterm-task.c","focused":false,"flexScale":1},"activePaneId":3},"packagesWithActiveGrammars":["language-c","language-hyperlink","language-todo"],"destroyedItemURIs":["/home/anirudh/Desktop/uclcode/C/Robotics/midterm.c","/home/anirudh/Desktop/uclcode/C/Robotics/all.c","/home/anirudh/Desktop/uclcode/C/Robotics/ir.c","/home/anirudh/Desktop/uclcode/C/Robotics/t2.c","/home/anirudh/Desktop/uclcode/C/Robotics/task1.c","/home/anirudh/Desktop/uclcode/C/Robotics/task2.c","/home/anirudh/Desktop/uclcode/C/Robotics/tasks.c","/home/anirudh/Desktop/uclcode/C/Robotics/ir-sensor-test.c","/home/anirudh/Desktop/uclcode/C/Robotics/test.c","/home/anirudh/Desktop/uclcode/C/Robotics/toh.c","/home/anirudh/Desktop/uclcode/C/Robotics/tutorial.c","/home/anirudh/Desktop/uclcode/C/Robotics/wall.c","/home/anirudh/Desktop/uclcode/C/Robotics/towers-of-hanoi.c"]},"packageStates":{"fuzzy-finder":{"/home/anirudh/Desktop/uclcode/C/Robotics/midterm-task.c":1462137441320},"metrics":{"sessionLength":273431},"tree-view":{"directoryExpansionStates":{"/home/anirudh/Desktop/uclcode/C/Robotics":{"isExpanded":false,"entries":{}}},"selectedPath":"/home/anirudh/Desktop/uclcode/C/Robotics","hasFocus":true,"attached":true,"scrollLeft":0,"scrollTop":0,"width":327}},"fullScreen":false}